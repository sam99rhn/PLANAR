<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLANAR - Planar Triangulated Graph Tool</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark);
            line-height: 1.6;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--dark) 100%);
            color: white;
            padding: 1rem;
            box-shadow: var(--shadow);
            z-index: 10;
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            display: flex;
            align-items: center;
        }
        
        .logo-icon {
            margin-right: 10px;
            font-size: 2rem;
        }
        
        .version {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-left: 10px;
        }
        
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background-color: white;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: var(--shadow);
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .panel {
            background-color: white;
            border-radius: 8px;
            padding: 1.2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--light);
            color: var(--primary);
            display: flex;
            align-items: center;
        }
        
        .panel-title i {
            margin-right: 10px;
        }
        
        .btn {
            display: inline-block;
            padding: 0.6rem 1.2rem;
            background-color: var(--secondary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        
        .btn-block {
            display: block;
            width: 100%;
        }
        
        .btn-success {
            background-color: var(--success);
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-warning {
            background-color: var(--warning);
        }
        
        .btn-warning:hover {
            background-color: #e67e22;
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .control-group {
            margin-bottom: 1.2rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .checkbox-group input {
            margin-right: 10px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: white;
        }
        
        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #graphCanvas:active {
            cursor: grabbing;
        }
        
        .status-bar {
            background-color: var(--dark);
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        .color-palette {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .color-box.active {
            border-color: var(--dark);
            transform: scale(1.1);
        }
        
        .instructions {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #666;
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid var(--secondary);
        }
        
        .tab-container {
            margin-top: 1rem;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 1rem;
        }
        
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--secondary);
            color: var(--secondary);
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            main {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 40%;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="logo">
                    <span class="logo-icon">⊡</span>
                    PLANAR <span class="version">v1.0</span>
                </div>
                <div>Planar Triangulated Graph Constructor & Coloring Tool</div>
            </div>
        </header>
        
        <main>
            <div class="sidebar">
                <div class="panel">
                    <h2 class="panel-title"><i class="icon">+</i> Graph Construction</h2>
                    <div class="btn-group">
                        <button id="addVertexBtn" class="btn btn-block">Add Vertex</button>
                        <button id="addEdgeBtn" class="btn btn-block">Add Edge</button>
                    </div>
                    <div class="btn-group">
                        <button id="triangulateBtn" class="btn btn-block btn-success">Triangulate</button>
                        <button id="clearBtn" class="btn btn-block btn-danger">Clear Graph</button>
                    </div>
                    
                    <div class="control-group">
                        <label for="vertexCount">Random Vertices:</label>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="number" id="vertexCount" min="3" max="100" value="10">
                            <button id="randomGraphBtn" class="btn">Generate</button>
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="snapToGrid" checked>
                        <label for="snapToGrid">Snap to grid</label>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="icon">🎨</i> Coloring</h2>
                    <div class="btn-group">
                        <button id="colorizeBtn" class="btn btn-block btn-success">Color Graph</button>
                        <button id="clearColorsBtn" class="btn btn-block">Clear Colors</button>
                    </div>
                    
                    <div class="control-group">
                        <label>Color Palette:</label>
                        <div class="color-palette">
                            <div class="color-box active" style="background-color: #FF6B6B;" data-color="#FF6B6B"></div>
                            <div class="color-box" style="background-color: #4ECDC4;" data-color="#4ECDC4"></div>
                            <div class="color-box" style="background-color: #FFE66D;" data-color="#FFE66D"></div>
                            <div class="color-box" style="background-color: #9b59b6;" data-color="#9b59b6"></div>
                            <div class="color-box" style="background-color: #3498db;" data-color="#3498db"></div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="coloringAlgorithm">Algorithm:</label>
                        <select id="coloringAlgorithm">
                            <option value="greedy">Greedy Coloring</option>
                            <option value="dsatur">DSATUR</option>
                        </select>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="icon">⚙️</i> Visualization</h2>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showLabels" checked>
                        <label for="showLabels">Show vertex labels</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid" checked>
                        <label for="showGrid">Show grid</label>
                    </div>
                    
                    <div class="btn-group">
                        <button id="zoomInBtn" class="btn btn-block">Zoom In</button>
                        <button id="zoomOutBtn" class="btn btn-block">Zoom Out</button>
                    </div>
                    <button id="resetViewBtn" class="btn btn-block btn-warning">Reset View</button>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
                <div class="tooltip" id="tooltip" style="display: none;"></div>
            </div>
        </main>
        
        <div class="status-bar">
            <div>Vertices: <span id="vertexCountDisplay">0</span> | Edges: <span id="edgeCountDisplay">0</span> | Triangles: <span id="triangleCountDisplay">0</span></div>
            <div>Status: <span id="statusMessage">Ready</span></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Canvas setup
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');
            
            // Resize canvas to fit window
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                drawGraph();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Graph data structure
            let graph = {
                vertices: [],
                edges: [],
                triangles: []
            };
            
            // View state
            let viewState = {
                scale: 1,
                offsetX: 0,
                offsetY: 0,
                lastX: 0,
                lastY: 0,
                dragging: false,
                mode: 'select', // Modes: select, addVertex, addEdge
                selectedVertex: null,
                hoverVertex: null
            };
            
            // Initialize with a sample graph
            function initSampleGraph() {
                graph.vertices = [
                    { id: 1, x: 400, y: 300, color: null, label: '1' },
                    { id: 2, x: 500, y: 200, color: null, label: '2' },
                    { id: 3, x: 600, y: 300, color: null, label: '3' },
                    { id: 4, x: 500, y: 400, color: null, label: '4' }
                ];
                
                graph.edges = [
                    { v1: 1, v2: 2 },
                    { v1: 2, v2: 3 },
                    { v1: 3, v2: 4 },
                    { v1: 4, v2: 1 },
                    { v1: 1, v2: 3 }
                ];
                
                graph.triangles = [
                    { v1: 1, v2: 2, v3: 3 },
                    { v1: 1, v2: 3, v3: 4 }
                ];
                
                updateCounts();
                drawGraph();
            }
            
            // Update status counts
            function updateCounts() {
                document.getElementById('vertexCountDisplay').textContent = graph.vertices.length;
                document.getElementById('edgeCountDisplay').textContent = graph.edges.length;
                document.getElementById('triangleCountDisplay').textContent = graph.triangles.length;
            }
            
            // Draw the graph
            function drawGraph() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Apply transformations for pan/zoom
                ctx.save();
                ctx.translate(viewState.offsetX, viewState.offsetY);
                ctx.scale(viewState.scale, viewState.scale);
                
                // Draw grid if enabled
                if (document.getElementById('showGrid').checked) {
                    drawGrid();
                }
                
                // Draw edges
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                
                for (const edge of graph.edges) {
                    const v1 = graph.vertices.find(v => v.id === edge.v1);
                    const v2 = graph.vertices.find(v => v.id === edge.v2);
                    
                    if (v1 && v2) {
                        ctx.beginPath();
                        ctx.moveTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.stroke();
                    }
                }
                
                // Draw triangles if any
                if (graph.triangles.length > 0) {
                    ctx.fillStyle = 'rgba(189, 195, 199, 0.2)';
                    
                    for (const triangle of graph.triangles) {
                        const v1 = graph.vertices.find(v => v.id === triangle.v1);
                        const v2 = graph.vertices.find(v => v.id === triangle.v2);
                        const v3 = graph.vertices.find(v => v.id === triangle.v3);
                        
                        if (v1 && v2 && v3) {
                            ctx.beginPath();
                            ctx.moveTo(v1.x, v1.y);
                            ctx.lineTo(v2.x, v2.y);
                            ctx.lineTo(v3.x, v3.y);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
                
                // Draw vertices
                for (const vertex of graph.vertices) {
                    ctx.beginPath();
                    ctx.arc(vertex.x, vertex.y, 10, 0, Math.PI * 2);
                    
                    // Use vertex color if available, otherwise default
                    ctx.fillStyle = vertex.color || '#e74c3c';
                    ctx.fill();
                    
                    // Draw outline
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw label if enabled
                    if (document.getElementById('showLabels').checked) {
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(vertex.label || vertex.id, vertex.x, vertex.y);
                    }
                }
                
                // Highlight selected vertex
                if (viewState.selectedVertex) {
                    const vertex = graph.vertices.find(v => v.id === viewState.selectedVertex);
                    if (vertex) {
                        ctx.beginPath();
                        ctx.arc(vertex.x, vertex.y, 15, 0, Math.PI * 2);
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }
                
                // Highlight hover vertex
                if (viewState.hoverVertex) {
                    const vertex = graph.vertices.find(v => v.id === viewState.hoverVertex);
                    if (vertex) {
                        ctx.beginPath();
                        ctx.arc(vertex.x, vertex.y, 12, 0, Math.PI * 2);
                        ctx.strokeStyle = '#f39c12';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // Draw grid
            function drawGrid() {
                const gridSize = 20;
                const width = canvas.width / viewState.scale;
                const height = canvas.height / viewState.scale;
                const startX = -viewState.offsetX / viewState.scale;
                const startY = -viewState.offsetY / viewState.scale;
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = startX; x < startX + width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, startY + height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = startY; y < startY + height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(startX + width, y);
                    ctx.stroke();
                }
            }
            
            // Convert screen coordinates to graph coordinates
            function screenToGraph(x, y) {
                return {
                    x: (x - viewState.offsetX) / viewState.scale,
                    y: (y - viewState.offsetY) / viewState.scale
                };
            }
            
            // Find vertex at coordinates
            function findVertexAt(x, y, tolerance = 15) {
                for (const vertex of graph.vertices) {
                    const dx = vertex.x - x;
                    const dy = vertex.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= tolerance / viewState.scale) {
                        return vertex;
                    }
                }
                return null;
            }
            
            // Add a new vertex
            function addVertex(x, y) {
                const newId = graph.vertices.length > 0 ? Math.max(...graph.vertices.map(v => v.id)) + 1 : 1;
                
                // Snap to grid if enabled
                if (document.getElementById('snapToGrid').checked) {
                    x = Math.round(x / 20) * 20;
                    y = Math.round(y / 20) * 20;
                }
                
                graph.vertices.push({
                    id: newId,
                    x: x,
                    y: y,
                    color: null,
                    label: newId.toString()
                });
                
                updateCounts();
                drawGraph();
                return newId;
            }
            
            // Add an edge between two vertices
            function addEdge(v1, v2) {
                // Check if edge already exists
                const edgeExists = graph.edges.some(edge => 
                    (edge.v1 === v1 && edge.v2 === v2) || (edge.v1 === v2 && edge.v2 === v1));
                
                if (!edgeExists && v1 !== v2) {
                    graph.edges.push({ v1: v1, v2: v2 });
                    updateCounts();
                    drawGraph();
                    return true;
                }
                return false;
            }
            
            // Triangulate the graph
            function triangulate() {
                // Simple implementation for demonstration
                // In a real application, you would use a proper triangulation algorithm
                
                if (graph.vertices.length < 3) {
                    setStatusMessage("Need at least 3 vertices to triangulate");
                    return;
                }
                
                // Clear existing triangles
                graph.triangles = [];
                
                // Create a simple triangulation (this is a placeholder)
                // For a real implementation, consider using Delaunay triangulation
                for (let i = 0; i < graph.vertices.length - 2; i++) {
                    graph.triangles.push({
                        v1: graph.vertices[i].id,
                        v2: graph.vertices[i+1].id,
                        v3: graph.vertices[i+2].id
                    });
                }
                
                // Add edges for the triangles
                for (const triangle of graph.triangles) {
                    addEdge(triangle.v1, triangle.v2);
                    addEdge(triangle.v2, triangle.v3);
                    addEdge(triangle.v3, triangle.v1);
                }
                
                setStatusMessage("Graph triangulated");
                updateCounts();
                drawGraph();
            }
            
            // Color the graph
            function colorGraph() {
                const algorithm = document.getElementById('coloringAlgorithm').value;
                
                // Simple greedy coloring algorithm
                if (algorithm === 'greedy') {
                    // Reset all colors
                    for (const vertex of graph.vertices) {
                        vertex.color = null;
                    }
                    
                    // Get the selected color palette
                    const activeColor = document.querySelector('.color-box.active').dataset.color;
                    
                    // Assign colors (this is a simplified implementation)
                    for (const vertex of graph.vertices) {
                        const adjacentColors = new Set();
                        
                        // Find all adjacent colors
                        for (const edge of graph.edges) {
                            if (edge.v1 === vertex.id) {
                                const adjacentVertex = graph.vertices.find(v => v.id === edge.v2);
                                if (adjacentVertex && adjacentVertex.color) {
                                    adjacentColors.add(adjacentVertex.color);
                                }
                            } else if (edge.v2 === vertex.id) {
                                const adjacentVertex = graph.vertices.find(v => v.id === edge.v1);
                                if (adjacentVertex && adjacentVertex.color) {
                                    adjacentColors.add(adjacentVertex.color);
                                }
                            }
                        }
                        
                        // Assign the first available color
                        if (!adjacentColors.has(activeColor)) {
                            vertex.color = activeColor;
                        } else {
                            // Fallback to a different color
                            vertex.color = '#FFE66D';
                        }
                    }
                }
                
                setStatusMessage("Graph colored using " + algorithm);
                drawGraph();
            }
            
            // Set status message
            function setStatusMessage(message) {
                document.getElementById('statusMessage').textContent = message;
                
                // Clear message after 3 seconds
                setTimeout(() => {
                    document.getElementById('statusMessage').textContent = "Ready";
                }, 3000);
            }
            
            // Event Listeners
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const graphPos = screenToGraph(x, y);
                
                if (e.button === 0) { // Left click
                    if (viewState.mode === 'addVertex') {
                        addVertex(graphPos.x, graphPos.y);
                        setStatusMessage("Vertex added");
                    } else {
                        const vertex = findVertexAt(graphPos.x, graphPos.y);
                        if (vertex) {
                            viewState.selectedVertex = vertex.id;
                            
                            if (viewState.mode === 'addEdge') {
                                if (viewState.lastSelectedVertex) {
                                    if (addEdge(viewState.lastSelectedVertex, vertex.id)) {
                                        setStatusMessage("Edge added");
                                    }
                                    viewState.lastSelectedVertex = null;
                                    viewState.mode = 'select';
                                } else {
                                    viewState.lastSelectedVertex = vertex.id;
                                }
                            }
                        } else {
                            viewState.selectedVertex = null;
                        }
                        
                        // Start panning
                        viewState.dragging = true;
                        viewState.lastX = x;
                        viewState.lastY = y;
                    }
                }
                
                drawGraph();
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const graphPos = screenToGraph(x, y);
                
                // Update tooltip position
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                
                // Find vertex under cursor
                const vertex = findVertexAt(graphPos.x, graphPos.y);
                if (vertex) {
                    viewState.hoverVertex = vertex.id;
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `Vertex ${vertex.id}<br>X: ${Math.round(vertex.x)} Y: ${Math.round(vertex.y)}`;
                } else {
                    viewState.hoverVertex = null;
                    tooltip.style.display = 'none';
                }
                
                // Handle panning
                if (viewState.dragging) {
                    const dx = x - viewState.lastX;
                    const dy = y - viewState.lastY;
                    
                    viewState.offsetX += dx;
                    viewState.offsetY += dy;
                    
                    viewState.lastX = x;
                    viewState.lastY = y;
                    
                    drawGraph();
                } else {
                    drawGraph();
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                viewState.dragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                viewState.dragging = false;
                viewState.hoverVertex = null;
                tooltip.style.display = 'none';
                drawGraph();
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = viewState.scale * delta;
                
                // Limit scale
                if (newScale > 0.1 && newScale < 5) {
                    // Adjust offset to zoom toward mouse position
                    viewState.offsetX = x - (x - viewState.offsetX) * delta;
                    viewState.offsetY = y - (y - viewState.offsetY) * delta;
                    
                    viewState.scale = newScale;
                    drawGraph();
                }
            });
            
            // Button event listeners
            document.getElementById('addVertexBtn').addEventListener('click', () => {
                viewState.mode = 'addVertex';
                setStatusMessage("Click on canvas to add a vertex");
            });
            
            document.getElementById('addEdgeBtn').addEventListener('click', () => {
                viewState.mode = 'addEdge';
                viewState.lastSelectedVertex = null;
                setStatusMessage("Select first vertex for the edge");
            });
            
            document.getElementById('triangulateBtn').addEventListener('click', triangulate);
            
            document.getElementById('clearBtn').addEventListener('click', () => {
                graph = { vertices: [], edges: [], triangles: [] };
                updateCounts();
                setStatusMessage("Graph cleared");
                drawGraph();
            });
            
            document.getElementById('randomGraphBtn').addEventListener('click', () => {
                const count = parseInt(document.getElementById('vertexCount').value) || 10;
                
                // Clear existing graph
                graph = { vertices: [], edges: [], triangles: [] };
                
                // Add random vertices
                for (let i = 0; i < count; i++) {
                    const x = 100 + Math.random() * (canvas.width - 200);
                    const y = 100 + Math.random() * (canvas.height - 200);
                    addVertex(x, y);
                }
                
                // Add some random edges
                for (let i = 0; i < count * 1.5; i++) {
                    const v1 = Math.floor(Math.random() * graph.vertices.length) + 1;
                    let v2 = Math.floor(Math.random() * graph.vertices.length) + 1;
                    
                    // Ensure v2 is different from v1
                    while (v2 === v1) {
                        v2 = Math.floor(Math.random() * graph.vertices.length) + 1;
                    }
                    
                    addEdge(v1, v2);
                }
                
                setStatusMessage("Random graph generated with " + count + " vertices");
                drawGraph();
            });
            
            document.getElementById('colorizeBtn').addEventListener('click', colorGraph);
            
            document.getElementById('clearColorsBtn').addEventListener('click', () => {
                for (const vertex of graph.vertices) {
                    vertex.color = null;
                }
                setStatusMessage("Colors cleared");
                drawGraph();
            });
            
            document.getElementById('zoomInBtn').addEventListener('click', () => {
                viewState.scale *= 1.2;
                drawGraph();
            });
            
            document.getElementById('zoomOutBtn').addEventListener('click', () => {
                viewState.scale /= 1.2;
                drawGraph();
            });
            
            document.getElementById('resetViewBtn').addEventListener('click', () => {
                viewState.scale = 1;
                viewState.offsetX = 0;
                viewState.offsetY = 0;
                setStatusMessage("View reset");
                drawGraph();
            });
            
            // Color palette selection
            document.querySelectorAll('.color-box').forEach(box => {
                box.addEventListener('click', () => {
                    document.querySelectorAll('.color-box').forEach(b => b.classList.remove('active'));
                    box.classList.add('active');
                });
            });
            
            // Toggle options
            document.getElementById('showLabels').addEventListener('change', drawGraph);
            document.getElementById('showGrid').addEventListener('change', drawGraph);
            
            // Initialize with a sample graph
            initSampleGraph();
            setStatusMessage("Welcome to PLANAR. Loaded sample graph.");
        });
    </script>
</body>
</html>
