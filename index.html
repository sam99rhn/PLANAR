<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PLANAR — Triangulated Graph Builder (optimized)</title>
<style>
:root{
  --bg:#0e0f12; --panel:#16181d; --ink:#eaeef5; --muted:#9aa3b2; --accent:#6aa6ff; --ok:#37d67a; --warn:#ffb020; --bad:#ff5c5c;
  --edge:#8792a2; --vfill:#2a2f3a; --grid:#151923;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
#app{display:grid;grid-template-columns:320px 1fr;grid-template-rows:auto 1fr;grid-template-areas:"top top" "side main";height:100%}
header{grid-area:top;display:flex;gap:12px;align-items:center;padding:10px 12px;border-bottom:1px solid #222;background:var(--panel);position:sticky;top:0;z-index:10}
header h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.3px}
header .sp{flex:1}
header button, header .btn{background:#1e2128;border:1px solid #262a33;color:var(--ink);padding:6px 10px;border-radius:10px;cursor:pointer}
header button:disabled{opacity:.45;cursor:not-allowed}
header input[type="number"], header input[type="text"], header input[type="color"]{background:#101218;border:1px solid #232733;color:var(--ink);padding:6px 8px;border-radius:8px}

aside{grid-area:side;border-right:1px solid #222;background:var(--panel);padding:12px;overflow:auto}
aside h2{font-size:13px;margin:12px 0 6px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
aside .group{display:grid;gap:8px;margin-bottom:10px}
aside .row{display:flex;gap:8px;flex-wrap:wrap}
aside .row>button{flex:1}
aside button{background:#1b1f27;border:1px solid #2a2f38;color:var(--ink);padding:8px 10px;border-radius:12px;cursor:pointer}
aside button:disabled{opacity:.45;cursor:not-allowed}
aside .kbd{font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0f1116;border:1px solid #1a1e27;padding:2px 6px;border-radius:6px;color:#c8d1e1}
#canvasWrap{grid-area:main;position:relative;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
canvas{position:absolute;inset:0;width:100%;height:100%;}
#status{position:absolute;left:10px;bottom:10px;background:#0f1218d9;border:1px solid #202532;color:var(--ink);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);display:flex;gap:10px;align-items:center}
#status span{opacity:.9}
#toast{position:absolute;right:12px;bottom:12px;max-width:420px;background:#0f1218;border:1px solid #2a3040;padding:10px 12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);display:none}
details{background:#10131a;border:1px solid #1e2330;border-radius:12px;padding:8px 10px}
summary{cursor:pointer;color:#cbd3e3}
code,pre{background:#0f1116;border:1px solid #1a1e27;padding:6px 8px;border-radius:8px;color:#d6def0}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#161a22;border:1px solid #242a36;color:#cbd3e3}
a{color:var(--accent)}
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>PLANAR — Triangulated Graph Builder</h1>
    <div class="sp"></div>
    <label title="Go to vertex m"><span class="pill">Gm</span> <input id="gmInput" type="number" min="3" value="3" style="width:90px"></label>
    <button id="btnRunTests" title="Run correctness tests">Run Tests</button>
    <button id="btnExportJson" title="Export graph JSON">Export</button>
    <input id="fileImport" type="file" accept="application/json" style="display:none">
    <button id="btnImportJson" title="Import graph JSON">Import</button>
    <button id="btnSavePng" title="Save PNG snapshot">Save PNG</button>
  </header>

  <aside>
    <h2>Graph</h2>
    <div class="group">
      <div class="row">
        <button id="btnStart" title="S">Start (S)</button>
        <button id="btnRandom" title="R">Random (R)</button>
        <button id="btnAdd" title="A">Add (A)</button>
      </div>
      <div class="row">
        <button id="btnUndo" title="Undo (Ctrl+Z)">Undo</button>
        <button id="btnRedo" title="Redo (Ctrl+Y)">Redo</button>
        <button id="btnRedraw" title="Re-layout periphery evenly">Redraw</button>
      </div>
    </div>

    <h2>View</h2>
    <div class="group">
      <div class="row">
        <button id="btnZoomIn" title="Z+">Zoom +</button>
        <button id="btnZoomOut" title="Z-">Zoom −</button>
        <button id="btnCenter" title="C">Center (C)</button>
        <button id="btnToggle" title="T">Toggle Labels/Colors (T)</button>
      </div>
      <small class="small">Pan: drag • Zoom: wheel</small>
    </div>

    <h2>Palette (1–4)</h2>
    <div class="group">
      <div class="row">
        <label>1 <input type="color" id="col1" value="#ff6b6b"></label>
        <label>2 <input type="color" id="col2" value="#6bcf63"></label>
        <label>3 <input type="color" id="col3" value="#6aa6ff"></label>
        <label>4 <input type="color" id="col4" value="#f4c95d"></label>
      </div>
      <div class="row">
        <button id="btnRecolor">Recolor (DSATUR)</button>
      </div>
    </div>

    <h2>Help</h2>
    <div class="group">
      <details open>
        <summary>Commands & Hotkeys</summary>
        <div style="padding-top:6px">
          <div><span class="kbd">S</span> Start triangle V1–V2–V3</div>
          <div><span class="kbd">R</span> Add random vertex (chooses Vp,Vq)</div>
          <div><span class="kbd">A</span> Add vertex: click Vp then Vq on periphery</div>
          <div><span class="kbd">Gm</span> Hide vertices &gt; m (header input)</div>
          <div><span class="kbd">Z+/Z-</span> Zoom in/out (or mouse wheel)</div>
          <div><span class="kbd">C</span> Center & fit to view</div>
          <div><span class="kbd">T</span> Toggle labels vs colors</div>
          <div><span class="kbd">Ctrl+Z / Ctrl+Y</span> Undo / Redo</div>
        </div>
      </details>
      <details>
        <summary>Construction Rule</summary>
        <p style="padding-top:6px">Each new vertex is added to the <em>periphery</em> (outer cycle) touching <strong>m &gt; 1 contiguous</strong> periphery vertices from <code>Vp</code> to <code>Vq</code> (clockwise). It connects to the two extremes and to all vertices in between, preserving triangulation by construction.</p>
      </details>
      <details>
        <summary>Notes</summary>
        <ul>
          <li>Edges curve subtly for long spans.</li>
          <li><em>Redraw</em> spreads periphery vertices evenly.</li>
          <li>LOD hides labels and simplifies drawing when zoomed out.</li>
        </ul>
      </details>
    </div>
  </aside>

  <div id="canvasWrap">
    <canvas id="graphCanvas"></canvas>
    <div id="status"><span id="statMsg">Ready.</span><span id="statCounts"></span></div>
    <div id="toast"></div>
  </div>
</div>

<script>
/* ============================
   Utilities
   ============================ */
const TAU=Math.PI*2;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function showToast(msg, kind="info", ms=2000){
  const el=document.getElementById('toast');
  el.textContent=msg; el.style.display='block';
  el.style.borderColor = kind==='error'? 'var(--bad)': kind==='warn'?'var(--warn)':'#2a3040';
  clearTimeout(showToast._t); showToast._t=setTimeout(()=>{el.style.display='none'}, ms);
}
function setStatus(msg){ document.getElementById('statMsg').textContent = msg; }
function setCounts(){ const n=graph.visibleVertexCount(); const e=graph.visibleEdgeCount(); const p=graph.periphery.length; document.getElementById('statCounts').textContent = ` | V: ${n} E: ${e} P: ${p} Zoom: ${view.scale.toFixed(2)}`; }

/* ============================
   State & simple helpers
   ============================ */
const state = { lastId:0, visibleMaxId:0 };
function uid(){ state.lastId++; return state.lastId; }

/* ============================
   Spatial Hash (grid) for fast picking & culling
   ============================ */
class SpatialHash {
  constructor(cell=100){
    this.cell = cell;
    this.buckets = new Map();
  }
  setCellSize(cell){
    if(cell<=0) return;
    this.cell = cell;
    this.clear();
  }
  _key(ix,iy){ return ix + ':' + iy; }
  clear(){ this.buckets.clear(); }
  insert(id,x,y){
    const ix = Math.floor(x/this.cell), iy = Math.floor(y/this.cell);
    const key = this._key(ix,iy);
    if(!this.buckets.has(key)) this.buckets.set(key, new Set());
    this.buckets.get(key).add(id);
  }
  remove(id,x,y){
    const ix = Math.floor(x/this.cell), iy = Math.floor(y/this.cell);
    const key = this._key(ix,iy);
    const s = this.buckets.get(key);
    if(s) { s.delete(id); if(s.size===0) this.buckets.delete(key); }
  }
  queryRegion(xmin,ymin,xmax,ymax){
    const ix0 = Math.floor(xmin/this.cell), iy0 = Math.floor(ymin/this.cell);
    const ix1 = Math.floor(xmax/this.cell), iy1 = Math.floor(ymax/this.cell);
    const out = new Set();
    for(let ix=ix0; ix<=ix1; ix++){
      for(let iy=iy0; iy<=iy1; iy++){
        const s = this.buckets.get(this._key(ix,iy));
        if(s) for(const id of s) out.add(id);
      }
    }
    return out;
  }
}

/* ============================
   Graph model
   ============================ */
const graph = {
  vertices: new Map(),   // id -> {id,x,y,color,hidden:false}
  adj: new Map(),        // id -> Set(neighbors)
  edges: new Set(),      // "a-b" with a<b
  periphery: [],         // ordered clock-wise outer cycle vertex ids

  reset(){
    this.vertices.clear();
    this.adj.clear();
    this.edges.clear();
    this.periphery = [];
    state.lastId = 0;
    state.visibleMaxId = 0;
    spatial.clear();
  },

  _edgeKey(a,b){ if(a>b){ [a,b]=[b,a]; } return `${a}-${b}`; },

  addVertex(x,y,color=1){
    const id = uid();
    this.vertices.set(id, { id, x, y, color, hidden:false });
    this.adj.set(id, new Set());
    spatial.insert(id, x, y);
    return id;
  },

  removeVertex(id){
    if(!this.vertices.has(id)) return false;
    const v = this.vertices.get(id);
    for(const n of this.adj.get(id)){
      this.adj.get(n).delete(id);
      this.edges.delete(this._edgeKey(id,n));
    }
    this.adj.delete(id);
    this.vertices.delete(id);
    // remove from periphery if present
    const idx = this.periphery.indexOf(id);
    if(idx!==-1) this.periphery.splice(idx,1);
    spatial.remove(id, v.x, v.y);
    return true;
  },

  addEdge(a,b){
    if(a===b) return false;
    if(!this.vertices.has(a) || !this.vertices.has(b)) return false;
    const key = this._edgeKey(a,b);
    if(this.edges.has(key)) return false;
    this.edges.add(key);
    this.adj.get(a).add(b);
    this.adj.get(b).add(a);
    return true;
  },

  hasEdge(a,b){ return this.edges.has(this._edgeKey(a,b)); },

  startTriangle(){
    this.reset();
    const cx=0, cy=0, r=200;
    const v1 = this.addVertex(cx + r*Math.cos(-Math.PI/2), cy + r*Math.sin(-Math.PI/2), 1);
    const v2 = this.addVertex(cx + r*Math.cos(-Math.PI/2 + 2*Math.PI/3), cy + r*Math.sin(-Math.PI/2 + 2*Math.PI/3), 2);
    const v3 = this.addVertex(cx + r*Math.cos(-Math.PI/2 + 4*Math.PI/3), cy + r*Math.sin(-Math.PI/2 + 4*Math.PI/3), 3);
    this.addEdge(v1,v2); this.addEdge(v2,v3); this.addEdge(v3,v1);
    this.periphery = [v1,v2,v3];
    state.visibleMaxId = Math.max(v1,v2,v3);
  },

  validateRun(Vp,Vq){
    const P = this.periphery;
    const i = P.indexOf(Vp), j = P.indexOf(Vq);
    if(i===-1 || j===-1) return { ok:false, reason:'Vp/Vq not on periphery' };
    if(Vp===Vq) return { ok:false, reason:'Vp and Vq must differ' };
    // build run clockwise from i to j inclusive
    const run=[];
    let k=i;
    while(true){
      run.push(P[k]);
      if(k===j) break;
      k = (k+1) % P.length;
      if(run.length> P.length + 1) break; // safety
    }
    if(run.length <= 1) return { ok:false, reason:'Run length must be > 1' };
    return { ok:true, run, i, j };
  },

  _peripheryCentroid(){
    if(this.periphery.length===0) return {x:0,y:0};
    let cx=0, cy=0;
    for(const id of this.periphery){
      const v = this.vertices.get(id);
      cx += v.x; cy += v.y;
    }
    return { x: cx / this.periphery.length, y: cy / this.periphery.length };
  },

  _placeNewVertex(run){
    // centroid of run
    let cx=0, cy=0;
    for(const id of run){ const v = this.vertices.get(id); cx += v.x; cy += v.y; }
    cx /= run.length; cy /= run.length;
    // outward direction -> from overall periphery centroid to run centroid
    const g = this._peripheryCentroid();
    let dx = cx - g.x, dy = cy - g.y;
    let len = Math.hypot(dx,dy);
    if(len < 1e-6){ dx = Math.random()-0.5; dy = Math.random()-0.5; len = Math.hypot(dx,dy); }
    dx/=len; dy/=len;
    const push = 30 + Math.random()*20;
    return { x: cx + dx*push, y: cy + dy*push };
  },

  addOnPeriphery(Vp,Vq){
    const vres = this.validateRun(Vp,Vq);
    if(!vres.ok) throw new Error(vres.reason);
    const { run, i, j } = vres;
    // compute new vertex position
    const pos = this._placeNewVertex(run);
    const newId = this.addVertex(pos.x, pos.y, ((state.lastId-1) % 4) + 1);
    // connect to every vertex in run
    for(const u of run) this.addEdge(newId, u);
    // update periphery: remove run (i..j inclusive) and insert newId at position i
    // Carefully handle wrap
    const P = this.periphery.slice(); // copy
    const newP = [];
    if(i <= j){
      // keep [0..i-1], then newId, then [j+1..end]
      for(let k=0;k<i;k++) newP.push(P[k]);
      newP.push(newId);
      for(let k=j+1;k<P.length;k++) newP.push(P[k]);
    } else {
      // wrap: run is i..end and 0..j
      // keep [j+1..i-1], but starting from 0 we will reassemble maintaining clockwise order starting at index 0
      // choose to keep vertices from j+1 to i-1 (in circular order)
      let k = (j+1) % P.length;
      while(k !== i){
        newP.push(P[k]); k = (k+1) % P.length;
      }
      // insert newId at the end (which corresponds to position i)
      newP.push(newId);
    }
    // ensure periphery has at least 3 if possible; else we still assign
    this.periphery = newP.length>0 ? newP : [newId];
    return newId;
  },

  addRandom(){
    const P = this.periphery;
    if(P.length < 2) throw new Error('Periphery too small');
    // choose random i,j with run length >1
    for(let attempts=0; attempts<50; attempts++){
      let i = Math.floor(Math.random()*P.length);
      let j = Math.floor(Math.random()*P.length);
      if(i===j) j=(j+1)%P.length;
      const vres = this.validateRun(P[i], P[j]);
      if(vres.ok && vres.run.length>1) return this.addOnPeriphery(P[i], P[j]);
    }
    // fallback: try sequential pairs
    for(let i=0;i<P.length;i++){
      const j=(i+2)%P.length;
      const vres = this.validateRun(P[i], P[j]);
      if(vres.ok && vres.run.length>1) return this.addOnPeriphery(P[i], P[j]);
    }
    throw new Error('Could not find a valid random run');
  },

  setVisibleMaxId(m){
    state.visibleMaxId = m;
    for(const [id,v] of this.vertices) v.hidden = id > m;
  },

  visibleVertexCount(){ let c=0; for(const v of this.vertices.values()) if(!v.hidden) c++; return c; },
  visibleEdgeCount(){ let c=0; for(const k of this.edges){ const [a,b]=k.split('-').map(Number); if(this.vertices.get(a) && this.vertices.get(b) && !this.vertices.get(a).hidden && !this.vertices.get(b).hidden) c++; } return c; },

  recolorDSATUR(){
    // Only consider visible vertices
    const visibles = [...this.vertices.values()].filter(v=>!v.hidden);
    if(visibles.length===0) return;
    for(const v of visibles) v.color = 0;
    const sat = new Map(); // id -> Set(colors)
    for(const v of visibles) sat.set(v.id, new Set());
    const deg = (id) => {
      let c=0;
      for(const n of this.adj.get(id)) if(this.vertices.get(n) && !this.vertices.get(n).hidden) c++;
      return c;
    };
    // initial ordering by degree
    const ids = visibles.map(v=>v.id).sort((a,b)=>deg(b)-deg(a));
    // pick first (max degree)
    const first = ids[0]; this.vertices.get(first).color = 1;
    for(const n of this.adj.get(first)) if(this.vertices.get(n) && !this.vertices.get(n).hidden) sat.get(n).add(1);
    const colored = new Set([first]);
    while(colored.size < ids.length){
      // choose with highest saturation (distinct neighbor colors), tie by degree
      let pick = null, bestSat=-1, bestDeg=-1;
      for(const id of ids) {
        if(colored.has(id)) continue;
        const s = sat.get(id).size;
        const d = deg(id);
        if(s>bestSat || (s===bestSat && d>bestDeg)){ pick=id; bestSat=s; bestDeg=d; }
      }
      if(pick===null) break;
      // smallest available color 1..4
      const used = sat.get(pick);
      let color=1; while(used.has(color) && color<=4) color++;
      if(color>4) color = ((Math.floor(Math.random()*4))+1);
      this.vertices.get(pick).color = color;
      colored.add(pick);
      for(const n of this.adj.get(pick)) if(this.vertices.get(n) && !this.vertices.get(n).hidden) sat.get(n).add(color);
    }
  },

  // triangulation invariant: E = 3N - 3 - p  (for triangulated planar graphs with p outer face vertices)
  checkTriangulationInvariant(){
    const N = [...this.vertices.values()].filter(v=>!v.hidden).length;
    const E = [...this.edges].filter(k=>{ const [a,b] = k.split('-').map(Number); return !this.vertices.get(a).hidden && !this.vertices.get(b).hidden; }).length;
    const p = this.periphery.length;
    return { ok: E === 3*N - 3 - p, N, E, p, expected: 3*N - 3 - p };
  },

  serialize(){
    return JSON.stringify({
      vertices: [...this.vertices.values()],
      edges: [...this.edges],
      periphery: [...this.periphery],
      lastId: state.lastId,
      visibleMaxId: state.visibleMaxId
    });
  },

  deserialize(json){
    const o = JSON.parse(json);
    this.vertices = new Map(o.vertices.map(v=>[v.id, v]));
    this.adj = new Map();
    for(const [id,v] of this.vertices) this.adj.set(id, new Set());
    this.edges = new Set(o.edges);
    for(const k of this.edges){
      const [a,b]=k.split('-').map(Number);
      if(!this.adj.has(a)) this.adj.set(a,new Set());
      if(!this.adj.has(b)) this.adj.set(b,new Set());
      this.adj.get(a).add(b); this.adj.get(b).add(a);
    }
    this.periphery = o.periphery || [];
    state.lastId = o.lastId || Math.max(...(this.periphery.length?this.periphery:[0]));
    state.visibleMaxId = o.visibleMaxId || state.lastId;
    // rebuild spatial
    spatial.clear();
    for(const [id,v] of this.vertices) spatial.insert(id, v.x, v.y);
  }
};

/* ============================
   Undo / Redo (history)
   ============================ */
const history = {
  stack: [], redo: [],
  push(){
    try{
      this.stack.push(graph.serialize());
      if(this.stack.length > 200) this.stack.shift(); // keep history bounded
      this.redo.length = 0;
    }catch(e){ console.warn('History push failed', e); }
  },
  canUndo(){ return this.stack.length > 0; },
  canRedo(){ return this.redo.length > 0; },
  undo(){
    if(!this.canUndo()) return;
    const cur = graph.serialize();
    const prev = this.stack.pop();
    this.redo.push(cur);
    graph.deserialize(prev);
    requestDraw();
    updateUI();
    setStatus('Undo');
  },
  redo(){
    if(!this.canRedo()) return;
    const cur = graph.serialize();
    const next = this.redo.pop();
    this.stack.push(cur);
    graph.deserialize(next);
    requestDraw();
    updateUI();
    setStatus('Redo');
  }
};

/* ============================
   Rendering & Viewport
   ============================ */
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
const offEdges = document.createElement('canvas');
const offVerts = document.createElement('canvas');
const edgesCtx = offEdges.getContext('2d');
const vertsCtx = offVerts.getContext('2d');

let needsRedraw=true;
function requestDraw(){ needsRedraw=true; }

const view = { x:0, y:0, scale:1, dragging:false, last:{x:0,y:0} };

function resize(){
  const wrap = document.getElementById('canvasWrap');
  const w = wrap.clientWidth, h = wrap.clientHeight;
  canvas.width = w; canvas.height = h;
  offEdges.width = w; offEdges.height = h;
  offVerts.width = w; offVerts.height = h;
  requestDraw();
}
window.addEventListener('resize', resize);

function worldToScreen(x,y){
  return { x: x*view.scale + canvas.width/2 + view.x, y: y*view.scale + canvas.height/2 + view.y };
}
function screenToWorld(x,y){
  return { x: (x - canvas.width/2 - view.x)/view.scale, y: (y - canvas.height/2 - view.y)/view.scale };
}

function centerFit(){
  const vs = [...graph.vertices.values()].filter(v=>!v.hidden);
  if(vs.length===0){ view.x=0; view.y=0; view.scale=1; requestDraw(); return; }
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const v of vs){ minx=Math.min(minx,v.x); maxx=Math.max(maxx,v.x); miny=Math.min(miny,v.y); maxy=Math.max(maxy,v.y); }
  const pad = 80;
  const w = Math.max(1, maxx - minx + pad*2), h = Math.max(1, maxy - miny + pad*2);
  const sx = canvas.width / w, sy = canvas.height / h;
  view.scale = clamp(Math.min(sx,sy), 0.05, 8);
  const cx = (minx + maxx)/2, cy = (miny + maxy)/2;
  const cs = worldToScreen(cx,cy);
  view.x += (canvas.width/2 - cs.x);
  view.y += (canvas.height/2 - cs.y);
  // update spatial cell size relative to scale
  spatial.setCellSize(Math.max(60, 120 / view.scale));
  requestDraw();
}

/* Helpers for CSS var */
function varCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name) || '#8892a0'; }

/* Layer invalidation flags */
const layers = { edgesDirty:true, vertsDirty:true };

/* Palette */
const palette = {1:'#ff6b6b',2:'#6bcf63',3:'#6aa6ff',4:'#f4c95d'} ;

/* LOD thresholds */
function getLODTier(){
  // 0: points only (very far out)
  // 1: edges visible, no labels
  // 2: full detail (edge curves, labels)
  if(view.scale < 0.25) return 0;
  if(view.scale < 0.6) return 1;
  return 2;
}

/* Draw functions with culling and caching */
function draw(){
  if(!needsRedraw) return;
  needsRedraw=false;
  setCounts();

  // clear main canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = varCSS('--bg');
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // grid light
  drawGrid();

  // prepare transforms for offscreen compositing
  [edgesCtx, vertsCtx].forEach(c=>{
    c.setTransform(view.scale, 0, 0, view.scale, canvas.width/2 + view.x, canvas.height/2 + view.y);
  });

  const lod = getLODTier();

  // compute viewport in world coords for culling
  const minW = screenToWorld(0,0).x;
  const minH = screenToWorld(0,0).y;
  const maxW = screenToWorld(canvas.width, canvas.height).x;
  const maxH = screenToWorld(canvas.width, canvas.height).y;

  // decide which vertices are in viewport using spatial hash
  const visibleIds = spatial.queryRegion(minW-100, minH-100, maxW+100, maxH+100);

  // Edges layer: redraw only when dirty or scale tier changed or when viewport changed significantly
  if(layers.edgesDirty || true){ // we redraw edges each frame but we cull heavy work
    edgesCtx.clearRect(-canvas.width, -canvas.height, canvas.width*3, canvas.height*3);
    edgesCtx.lineWidth = Math.max(0.8 / view.scale, 0.4);
    edgesCtx.strokeStyle = varCSS('--edge');
    edgesCtx.beginPath();
    for(const k of graph.edges){
      const [a,b] = k.split('-').map(Number);
      const va = graph.vertices.get(a), vb = graph.vertices.get(b);
      if(!va || !vb || va.hidden || vb.hidden) continue;
      // cull if both vertices outside viewport plus margin
      if(!visibleIds.has(a) && !visibleIds.has(b)) continue;
      drawEdge(edgesCtx, va, vb);
    }
    edgesCtx.stroke();
    layers.edgesDirty = false;
  }

  // Verts layer
  vertsCtx.clearRect(-canvas.width, -canvas.height, canvas.width*3, canvas.height*3);
  for(const id of visibleIds){
    const v = graph.vertices.get(id);
    if(!v || v.hidden) continue;
    drawVertex(vertsCtx, v, lod === 2);
  }

  // Composite layers onto main canvas
  ctx.drawImage(offEdges, 0, 0);
  ctx.drawImage(offVerts, 0, 0);
}

/* draw grid */
function drawGrid(){
  const step = 50 * view.scale;
  if(step < 9) return;
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = varCSS('--grid');
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.beginPath();
  ctx.strokeStyle = '#161a22';
  ctx.lineWidth = 1;
  const ox = (canvas.width/2 + view.x) % step;
  const oy = (canvas.height/2 + view.y) % step;
  for(let x = ox; x < canvas.width; x += step){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
  for(let y = oy; y < canvas.height; y += step){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
  ctx.stroke();
  ctx.restore();
}

/* draw edge: curved for long spans */
function drawEdge(c, a, b){
  const dx = b.x - a.x, dy = b.y - a.y;
  const d = Math.hypot(dx,dy);
  if(d > 240){
    const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;
    const nx = -dy/d, ny = dx/d;
    const bulge = Math.min(0.14*d, 80);
    c.moveTo(a.x, a.y);
    c.quadraticCurveTo(mx + nx*bulge, my + ny*bulge, b.x, b.y);
  } else {
    c.moveTo(a.x, a.y); c.lineTo(b.x, b.y);
  }
}

/* draw vertex */
function drawVertex(c, v, showLabel){
  const fill = palette[v.color] || '#999';
  // adaptive radius (in world units)
  const r = clamp(6 + String(v.id).length*1.2, 6, 14) / Math.sqrt(view.scale);
  c.beginPath(); c.fillStyle = fill; c.strokeStyle = '#0b0d12'; c.lineWidth = Math.max(1 / view.scale, 0.6);
  c.arc(v.x, v.y, r, 0, TAU); c.fill(); c.stroke();
  if(showLabel){
    // draw number in screen-space for crispness
    c.save();
    c.scale(1/view.scale, 1/view.scale);
    c.fillStyle = '#0b0d12';
    const fontPx = Math.max(9, 12);
    c.font = `${fontPx}px ui-sans-serif`;
    const s = String(v.id);
    const measure = c.measureText(s);
    // measure.width is in CSS px but coords are scaled, so we offset accordingly
    c.fillText(s, (v.x*view.scale) - measure.width/2, (v.y*view.scale) + fontPx/3);
    c.restore();
  }
}

/* ============================
   Layout: distribute periphery evenly
   ============================ */
function layoutPeriphery(){
  const P = graph.periphery;
  if(P.length < 3) return;
  // centroid of periphery
  let cx=0, cy=0;
  for(const id of P){ const v = graph.vertices.get(id); cx+=v.x; cy+=v.y; }
  cx/=P.length; cy/=P.length;
  // choose radius based on current bounding
  let maxR = 0;
  for(const id of P){ const v = graph.vertices.get(id); maxR = Math.max(maxR, Math.hypot(v.x-cx, v.y-cy)); }
  const r = Math.max(140, maxR);
  for(let k=0;k<P.length;k++){
    const t = -Math.PI/2 + TAU*(k/P.length);
    const v = graph.vertices.get(P[k]); v.x = cx + r*Math.cos(t); v.y = cy + r*Math.sin(t);
    spatial.remove(v.id, 0,0); // clear possible stale
    spatial.insert(v.id, v.x, v.y);
  }
  layers.vertsDirty = true; layers.edgesDirty = true;
}

/* ============================
   Interaction helpers (hit-testing)
   ============================ */
function pickVertexAt(mx,my){
  const w = screenToWorld(mx,my);
  // query spatial around point
  const candidates = spatial.queryRegion(w.x-30, w.y-30, w.x+30, w.y+30);
  let best = null, bestD = 15 / view.scale;
  for(const id of candidates){
    const v = graph.vertices.get(id);
    if(!v || v.hidden) continue;
    const d = Math.hypot(v.x - w.x, v.y - w.y);
    if(d < bestD){ best = v; bestD = d; }
  }
  return best;
}

/* ============================
   Interaction & Events
   ============================ */
let mode = { addPicking:false, pickVp:null };

canvas.addEventListener('mousedown', e=>{
  if(e.button === 0){ // left
    if(mode.addPicking){
      const v = pickVertexAt(e.offsetX, e.offsetY);
      if(!v){ showToast('No vertex at that point', 'warn'); return; }
      if(!graph.periphery.includes(v.id)){ showToast('Vertex not on periphery', 'error'); return; }
      if(!mode.pickVp){ mode.pickVp = v.id; setStatus(`Picked Vp = V${v.id}. Now pick Vq.`); return; }
      if(mode.pickVp === v.id){ showToast('Vp and Vq must differ', 'error'); return; }
      try{
        history.push();
        const newId = graph.addOnPeriphery(mode.pickVp, v.id);
        layoutPeriphery();
        layers.edgesDirty = layers.vertsDirty = true;
        requestDraw(); setStatus(`Added V${newId}`); updateUI();
      } catch(err){
        showToast(err.message, 'error');
      } finally {
        mode.addPicking = false; mode.pickVp = null;
      }
    } else {
      view.dragging = true; view.last.x = e.clientX; view.last.y = e.clientY;
    }
  } else if(e.button === 2){
    // right click: could be used in future for context menu
  }
});
window.addEventListener('mousemove', e=>{
  if(view.dragging){
    view.x += (e.clientX - view.last.x);
    view.y += (e.clientY - view.last.y);
    view.last.x = e.clientX; view.last.y = e.clientY;
    layers.edgesDirty = layers.vertsDirty = true;
    requestDraw();
  }
});
window.addEventListener('mouseup', ()=>{ view.dragging = false; });

canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor = (e.deltaY < 0) ? 1.12 : 0.88;
  zoomAt(e.offsetX, e.offsetY, factor);
}, { passive:false });

function zoomAt(mx,my,factor){
  const pre = screenToWorld(mx,my);
  view.scale = clamp(view.scale * factor, 0.05, 12);
  // update spatial granularity as scale changes
  spatial.setCellSize(Math.max(40, 120 / view.scale));
  const post = screenToWorld(mx,my);
  view.x += (post.x - pre.x) * view.scale;
  view.y += (post.y - pre.y) * view.scale;
  layers.edgesDirty = layers.vertsDirty = true;
  requestDraw();
}

/* ============================
   Buttons & UI wiring
   ============================ */
function updateUI(){
  const hasGraph = graph.periphery.length >= 3;
  document.getElementById('btnAdd').disabled = !hasGraph;
  document.getElementById('btnRandom').disabled = !hasGraph;
  document.getElementById('btnUndo').disabled = !history.canUndo();
  document.getElementById('btnRedo').disabled = !history.canRedo();
}
document.getElementById('btnStart').onclick = ()=>{ history.push(); graph.startTriangle(); centerFit(); layers.edgesDirty = layers.vertsDirty = true; requestDraw(); setStatus('Started'); updateUI(); };
document.getElementById('btnRandom').onclick = ()=>{ try{ history.push(); const id = graph.addRandom(); layoutPeriphery(); layers.edgesDirty = layers.vertsDirty = true; requestDraw(); setStatus(`Added V${id}`); updateUI(); }catch(err){ showToast(err.message,'error'); } };
document.getElementById('btnAdd').onclick = ()=>{ if(graph.periphery.length<3) { showToast('Start graph first (S)','warn'); return; } mode.addPicking=true; mode.pickVp=null; setStatus('Pick Vp then Vq on periphery...'); };
document.getElementById('btnUndo').onclick = ()=>history.undo();
document.getElementById('btnRedo').onclick = ()=>history.redo();
document.getElementById('btnRedraw').onclick = ()=>{ layoutPeriphery(); layers.edgesDirty = layers.vertsDirty = true; requestDraw(); setStatus('Periphery redrawn'); };

document.getElementById('btnZoomIn').onclick = ()=>zoomAt(canvas.width/2, canvas.height/2, 1.2);
document.getElementById('btnZoomOut').onclick = ()=>zoomAt(canvas.width/2, canvas.height/2, 0.8333);
document.getElementById('btnCenter').onclick = ()=>centerFit();

let showLabels = true;
document.getElementById('btnToggle').onclick = ()=>{ showLabels = !showLabels; layers.vertsDirty = true; requestDraw(); setStatus(showLabels? 'Labels on':'Labels off'); };

document.getElementById('gmInput').addEventListener('change', e=>{
  const m = parseInt(e.target.value||"0",10);
  if(isNaN(m) || m<0){ showToast('Invalid number','warn'); return; }
  graph.setVisibleMaxId(m);
  layers.edgesDirty = layers.vertsDirty = true;
  requestDraw(); setStatus(`Showing up to vertex ${m}`);
});

/* palette bindings */
for(let i=1;i<=4;i++){
  document.getElementById('col'+i).addEventListener('input', (e)=>{ palette[i]=e.target.value; layers.vertsDirty = true; requestDraw(); });
}
document.getElementById('btnRecolor').onclick = ()=>{ history.push(); graph.recolorDSATUR(); layers.vertsDirty=true; requestDraw(); setStatus('Recolored (DSATUR)'); };

/* export / import / png */
document.getElementById('btnExportJson').onclick = ()=>{
  try{
    const blob = new Blob([graph.serialize()], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'planar_graph.json'; a.click(); URL.revokeObjectURL(url);
  }catch(e){ showToast('Export failed','error'); }
};
document.getElementById('btnImportJson').onclick = ()=>document.getElementById('fileImport').click();
document.getElementById('fileImport').addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  const rd = new FileReader();
  rd.onload = ()=>{ try{ history.push(); graph.deserialize(rd.result); layers.edgesDirty = layers.vertsDirty = true; requestDraw(); setStatus('Imported'); updateUI(); }catch(err){ showToast('Invalid file','error'); } };
  rd.readAsText(f);
});
document.getElementById('btnSavePng').onclick = ()=>{
  const url = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.href = url; a.download = 'planar_graph.png'; a.click();
};

/* Run unit-ish tests: build moderate graph then test invariants */
document.getElementById('btnRunTests').onclick = ()=>{
  try{
    const snap = graph.serialize();
    if(graph.periphery.length < 3) graph.startTriangle();
    // add ~300 vertices as a moderate test, keeping UI responsive
    const addCount = 300;
    let added = 0;
    const t0 = performance.now();
    while(added < addCount){
      graph.addRandom();
      if(added % 6 === 0) layoutPeriphery();
      added++;
    }
    const inv = graph.checkTriangulationInvariant();
    graph.deserialize(snap);
    if(!inv.ok) showToast(`Triangulation failed: E=${inv.E} expected ${inv.expected}`, 'error', 4000);
    else showToast(`Tests OK — N=${inv.N} E=${inv.E} P=${inv.p}`, 'info', 2200);
  }catch(err){ showToast('Test error: '+err.message,'error',3000); }
};

/* Hotkeys */
window.addEventListener('keydown', e=>{
  if(e.ctrlKey && e.key.toLowerCase() === 'z'){ e.preventDefault(); history.undo(); return; }
  if(e.ctrlKey && e.key.toLowerCase() === 'y'){ e.preventDefault(); history.redo(); return; }
  if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
  const k = e.key.toLowerCase();
  if(k === 's') document.getElementById('btnStart').click();
  else if(k === 'r') document.getElementById('btnRandom').click();
  else if(k === 'a') document.getElementById('btnAdd').click();
  else if(k === 'c') document.getElementById('btnCenter').click();
  else if(k === 't') document.getElementById('btnToggle').click();
  else if(k === '+') document.getElementById('btnZoomIn').click();
  else if(k === '-') document.getElementById('btnZoomOut').click();
});

/* ============================
   Initialization
   ============================ */

const spatial = new SpatialHash(120); // will be tuned by centerFit
// initialize viewport sizing
resize();
setStatus('Ready. Press S to start.');
setCounts();
updateUI();

// Seed with a triangle for convenience
graph.startTriangle();
centerFit();
layers.edgesDirty = layers.vertsDirty = true;
requestDraw();

/* Animation loop */
function tick(){
  draw();
  requestAnimationFrame(tick);
}
tick();

/* expose a few things to window for debugging (optional) */
window._PLANAR = { graph, view, spatial, history, layoutPeriphery };

</script>
</body>
</html>
